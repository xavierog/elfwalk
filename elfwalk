#!/usr/bin/perl -w

# A simple toy script displaying the contents of an ELF file.

# (c) 2015 - Xavier G.
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

# About formats implemented:
#  ELF32 follows http://www.skyfree.org/linux/references/ELF_Format.pdf
#  ELF64 follows http://uclibc.org/docs/elf-64-gen.pdf

# About the naming of functions: this script uses camel case for functions.
# I wish to quote a friend of mine about that:
#   < gradator> c'est d'la merde le CamelCase
# That's it.

use strict;
use Fcntl;
use Term::ANSIColor qw(coloralias colored);
use Data::Dumper;

# Constants
use constant {
	UNSIGNED => 0,
	SIGNED => 1,
	LITTLE_ENDIAN => 0,
	BIG_ENDIAN => 1,
	ELFCLASS32 => 1,
	ELFCLASS64 => 2,
};

# ELF data types
# Notes:
#   - alignment was not included as it always equals size.
#   - see http://perldoc.perl.org/constant.html#CAVEATS if you wonder about the
#     parenthesis after ELFCLASS constants.
our $elf_data_types = {
	ELFCLASS32() => {
		# Figure 1-2: 32-Bit Data Types
		'Addr'   => { 'size' => 4, 'formatter' => '0x%08X',  'signed' => UNSIGNED },
		'Half'   => { 'size' => 2, 'formatter' => '0x%04X',  'signed' => UNSIGNED },
		'Off'    => { 'size' => 4, 'formatter' => '0x%08X',  'signed' => UNSIGNED },
		'Sword'  => { 'size' => 4, 'formatter' => '0x%08X',  'signed' =>   SIGNED },
		'Word'   => { 'size' => 4, 'formatter' => '0x%08X',  'signed' => UNSIGNED },
		'char'   => { 'size' => 1, 'formatter' => '%d',      'signed' => UNSIGNED },
	},
	ELFCLASS64() => {
		# Table 1. ELF-64 Data Types
		'Addr'   => { 'size' => 8, 'formatter' => '0x%016X', 'signed' => UNSIGNED },
		'Off'    => { 'size' => 8, 'formatter' => '0x%016X', 'signed' => UNSIGNED },
		'Half'   => { 'size' => 2, 'formatter' => '0x%04X',  'signed' => UNSIGNED },
		'Word'   => { 'size' => 4, 'formatter' => '0x%08X',  'signed' => UNSIGNED },
		'Sword'  => { 'size' => 4, 'formatter' => '0x%08X',  'signed' =>   SIGNED },
		'Xword'  => { 'size' => 8, 'formatter' => '0x%016X', 'signed' => UNSIGNED },
		'Sxword' => { 'size' => 8, 'formatter' => '0x%016X', 'signed' =>   SIGNED },
		'char'   => { 'size' => 1, 'formatter' => '%d',      'signed' => UNSIGNED },
	},
};

our $elf_structures = {
	# Figure 2. ELF-64 Header
	'file_header' => {
		'ordered_entries' => [
			'e_type',
			'e_machine',
			'e_version',
			'e_entry',
			'e_phoff',
			'e_shoff',
			'e_flags',
			'e_ehsize',
			'e_phentsize',
			'e_phnum',
			'e_shentsize',
			'e_shnum',
			'e_shstrndx',
		],
		'e_type' => 'Half',
		'e_machine' => 'Half',
		'e_version' => 'Word',
		'e_entry' => 'Addr',
		'e_phoff' => 'Off',
		'e_shoff' => 'Off',
		'e_flags' => 'Word',
		'e_ehsize' => 'Half',
		'e_phentsize' => 'Half',
		'e_phnum' => 'Half',
		'e_shentsize' => 'Half',
		'e_shnum' => 'Half',
		'e_shstrndx' => 'Half',
	},
	# Figure 3. ELF-64 Section Header
	'section_header' => {
		'ordered_entries' => [
			'sh_name',
			'sh_type',
			'sh_flags',
			'sh_addr',
			'sh_offset',
			'sh_size',
			'sh_link',
			'sh_info',
			'sh_addralign',
			'sh_entsize',
		],
		'sh_name' => 'Word',
		'sh_type' => 'Word',
		'sh_flags' => 'Xword',
		'sh_addr' => 'Addr',
		'sh_offset' => 'Off',
		'sh_size' => 'Xword',
		'sh_link' => 'Word',
		'sh_info' => 'Word',
		'sh_addralign' => 'Xword',
		'sh_entsize' => 'Xword',
	},
};

our $elf = {
	# Table 6. Object File Types, e_type
	'e_type' => {
		'unexplained_value' => 'fatal',
		'name' => {
			0 => 'ET_NONE',
			1 => 'ET_REL',
			2 => 'ET_EXEC',
			3 => 'ET_DYN',
			4 => 'ET_CORE',
		},
		'meaning' => {
			 0 => 'no file type',
			 1 => 'relocatable object file',
			 2 => 'executable file',
			 3 => 'shared object file',
			 4 => 'core file',
		},
		'ranges' => {
			'OS' => {
				'meaning' => 'environment-specific use',
				'low_value' => 0xFE00,
				'low_name' => 'ET_LOOS',
				'high_value' => 0xFEFF,
				'high_name' => 'ET_HIOS',
			},
			'PROC' => {
				'meaning' => 'processor-specific use',
				'low_value' => 0xFF00,
				'low_name' => 'ET_LOPROC',
				'high_value' => 0xFFFF,
				'high_name' => 'ET_HIPROC',
			},
		},
	},
	'e_machine' => {
		'single_meaning' => 'identifies the target architecture',
	},
	'e_version' => {
		'name' => { 1 => 'EV_CURRENT' },
		'meaning' => { 1 => 'this is the expected version of the object file format' },
		'unexplained_value' => 'i.e. not EV_CURRENT, ignoring',
	},
	'e_entry' => {
		'single_meaning' => 'contains the virtual address of the program entry point',
	},
	'e_phoff' => {
		'single_meaning' => 'contains the file offset, in bytes, of the program header table',
	},
	'e_shoff' => {
		'single_meaning' => 'contains the file offset, in bytes, of the section header table',
	},
	'e_flags' => {
		'single_meaning' => 'contains processor-specific flags',
	},
	'e_ehsize' => {
		'single_meaning' => 'contains the size, in bytes, of the ELF header',
	},
	'e_phentsize' => {
		'single_meaning' => 'contains the size, in bytes, of a program header table entry',
	},
	'e_phnum' => {
		'single_meaning' => 'contains the number of entries in the program header table',
	},
	'e_shentsize' => {
		'single_meaning' => 'contains the size, in bytes, of a section header table entry',
	},
	'e_shnum' => {
		'single_meaning' => 'contains the number of entries in the section header table',
	},
	'e_shstrndx' => {
		'single_meaning' => 'this is, within the section header table, the index of the section containing the section names',
	},
	'sh_name' => {
		'single_meaning' => 'this offset is used to locate the section name',
	},
	# Table 8. Section Types, sh_type
	'sh_type' => {
		'name' => {
			0 => 'SHT_NULL',
			1 => 'SHT_PROGBITS',
			2 => 'SHT_SYMTAB',
			3 => 'SHT_STRTAB',
			4 => 'SHT_RELA',
			5 => 'SHT_HASH',
			6 => 'SHT_DYNAMIC',
			7 => 'SHT_NOTE',
			8 => 'SHT_NOBITS',
			9 => 'SHT_REL',
			10 => 'SHT_SHLIB',
			11 => 'SHT_DYNSYM',
		},
		'meaning' => {
			0 => 'marks an unused section header',
			1 => 'contains information defined by the program',
			2 => 'contains a linker symbol table',
			3 => 'contains a string table',
			4 => 'contains "Rela" type relocation entries',
			5 => 'contains a symbol hash table',
			6 => 'contains dynamic linking tables',
			7 => 'contains note information',
			8 => 'contains uninitialized space; does not occupy any space in the file',
			9 => 'contains "Rel" type relocation entries',
			10 => 'reserved',
			11 => 'contains a dynamic loader symbol table',
		},
		'ranges' => {
			'OS' => {
				'meaning' => 'environment-specific use',
				'low_value' => 0x60000000,
				'low_name' => 'SHT_LOOS',
				'high_value' => 0x6FFFFFFF,
				'high_name' => 'SHT_HIOS',
			},
			'PROC' => {
				'meaning' => 'processor-specific use',
				'low_value' => 0x70000000,
				'low_name' => 'SHT_LOPROC',
				'high_value' => 0x7FFFFFFF,
				'high_name' => 'SHT_HIPROC',
			},
		},
	},
	# Table 9. Section Attributes, sh_flags
	'sh_flags' => {
		'is_flag' => 1,
		'name' => {
			1 => 'SHF_WRITE',
			2 => 'SHF_ALLOC',
			4 => 'SHF_EXECINSTR',
			0x0F000000 => 'SHT_MASKOS',
			0xF0000000 => 'SHT_MASKPROC',
		},
		'meaning' => {
			1 => 'section contains writable data',
			2 => 'section is allocated in memory image of program',
			4 => 'section contains executable instructions',
			0x0F000000 => 'environment-specific use',
			0xF0000000 => 'processor-specific use',
		},
	},
	'sh_addr' => {
		'single_meaning' => 'virtual address of the section in memory',
	},
	'sh_offset' => {
		'single_meaning' => 'offset, in bytes, of the section contents in the file',
	},
	'sh_size' => {
		'single_meaning' => 'size, in bytes, of the section',
	},
	'sh_link' => {
		'single_meaning' => 'index of an associated section',
		'_use' => {
			# Table 10. Use of the sh_link Field
			6  => 'a string table used by entries in this section',
			5  => 'a symbol table to which the hash table applies',
			9  => 'a symbol table referenced by relocations',
			4  => 'a symbol table referenced by relocations',
			2  => 'a string table used by entries in this section',
			11 => 'a string table used by entries in this section',
		}
	},
	'sh_info' => {
		'single_meaning' => 'extra information about the section',
		'_use' => {
			# Table 11. Use of the sh_info Field
			9  => 'the index of the section to which relocations apply',
			4  => 'the index of the section to which relocations apply',
			2  => 'the index of the first non-local symbol (i.e., number of local symbols)',
			11 => 'the index of the first non-local symbol (i.e., number of local symbols)',
		}
	},
	'sh_addralign' => {
		'single_meaning' => 'contains the required alignment of the section',
	},
	'sh_entsize' => {
		'single_meaning' => 'size, in bytes, of each entry; only makes sense for sections that contain fixed-size entries',
	},
};

# Simple arguments parsing: require one and exactly one argument.
usage() if @ARGV != 1;

# That arguments is expected to be an existing, readable file.
our $elf_filepath = $ARGV[0];
unless (-f $elf_filepath && -r $elf_filepath) {
	exitWithMessage(120, sprintf('%s either does not exist or is not readable.', $elf_filepath));
}

coloralias('main_action', 'bright_yellow');
coloralias('error', 'red');
coloralias('index', 'bright_white');
coloralias('offset', 'yellow');
coloralias('value_name', 'bright_white');
coloralias('value', 'cyan');
coloralias('name', 'green');
coloralias('flag_name', 'green');
coloralias('flag_value', 'cyan');

my $default_class     = ELFCLASS64;
my $default_endianess = LITTLE_ENDIAN;

# Open the file
our $elf_fh;
our $opening = open($elf_fh, '<' . $elf_filepath);
if (!$opening) {
	exitWithMessage(115, sprintf('Unable to open %s: %s', $elf_filepath, $!));
}
binmode($elf_fh);
walkELF($elf_fh);
close($elf_fh);

sub say {
	my $indent = shift;
	$indent = '  'x$indent;
	my $string;
	for my $str (@_) {
		next if (!defined($str));
		$string = $str;
		$string =~ s/^/${indent}/mgs;
		print $string . "\n";
	}
}

sub exitWithMessage {
	my $rc = $_[0];
	my $message = $_[1];
	print "Error: " unless ($rc == 0);
	print $message . "\n";
	exit($rc);
}

sub usage {
	print "Usage: ${0} file\n";
	exit(125);
}

sub setDefaultEndianess {
	$default_endianess = shift;
}

sub setDefaultClass {
	$default_class = shift;
}

sub typeInfo {
	my $type = shift;
	my $class = shift;

	$class = $default_class if (!defined($class));

	if (!exists($elf_data_types->{$class})) {
		exitWithMessage(150, "tried to work with unknown ELF class (${class})");
	}

	if (!exists($elf_data_types->{$class}->{$type})) {
		exitWithMessage(148, "tried to work with unknown type (${type})");
	}

	return $elf_data_types->{$class}->{$type};
}

# Expected arguments:
#   - file descriptor
#   - type, e.g. 'Half', 'Word', 'Addr', etc.
#   - ELF Class, e.g. ELFCLASS32 or ELFCLASS64
#   - endianess: either LITTLE_ENDIAN or BIG_ENDIAN
sub readELFValue {
	my $fd = shift;
	my $type = shift;
	my $class = shift;
	my $endianess = shift;

	# Default values.
	$class = $default_class if (!defined($class));
	$endianess = $default_endianess if (!defined($endianess));

	my $type_info = typeInfo($type, $class);

	return readValue(
		$fd,
		$type_info->{'size'},
		$type_info->{'signed'},
		$endianess
	);
}

# Expected arguments:
#   - file descriptor
#   - amount of bytes to read and parse
#   - 0 for unsigned, 1 for signed
#   - endianess: either LITTLE_ENDIAN or BIG_ENDIAN
sub readValue {
	my $fd = shift;
	my $size = shift;
	my $signed = shift;
	my $endianess = shift;

	# Check arguments.
	if (!defined($signed) || ($signed != SIGNED && $signed != UNSIGNED)) {
		exitWithMessage(8, 'attempted to call readValue with invalid signedness');
	}
	if (!defined($endianess) || ($endianess != LITTLE_ENDIAN && $endianess != BIG_ENDIAN)) {
		exitWithMessage(8, 'attempted to call readValue with invalid endianess');
	}

	my $data;
	my $reading = read($fd, $data, $size);
	if (!defined($reading)) {
		exitWithMessage(6, "error when attempting to read %d bytes: %s.", $size, $!);
	}
	elsif ($reading == 0) {
		exitWithMessage(5, "reached end of file.");
	}
	elsif ($reading != $size) {
		exitWithMessage(4, "was asked to read %d bytes but could only read %d.", $size, $reading);
	}

	my $unpack_arg;
	if ($size == 1) {
		$unpack_arg = ($signed ? 'c' : 'C');
	}
	elsif ($size == 2 || $size == 4) {
		# n stands for "network" (i.e. big-endian)
		# v stands for "VAX" (i.e. little-endian)
		$unpack_arg = $endianess ? 'n' : 'v';
		# lowercase is 16 bits, uppercase is 32 bits
		$unpack_arg = uc($unpack_arg) if ($size == 4);
		$unpack_arg .= '!' if ($signed);
	}
	elsif ($size == 8) {
		$unpack_arg = ($signed ? 'q' : 'Q') . ($endianess ? '>' : '<');
	}
	return unpack($unpack_arg, $data);
	# Unpack cheat sheet:
	#   n  An unsigned short (16-bit) in "network" (big-endian) order.
	#   N  An unsigned long (32-bit) in "network" (big-endian) order.
	#   v  An unsigned short (16-bit) in "VAX" (little-endian) order.
	#   V  An unsigned long (32-bit) in "VAX" (little-endian) order
	#   n! A signed short (16-bit) in "network" (big-endian) order.
	#   N! A signed long (32-bit) in "network" (big-endian) order.
	#   v! A signed short (16-bit) in "VAX" (little-endian) order.
	#   V! A signed long (32-bit) in "VAX" (little-endian) order
	#   q> A signed quad (64-bit) value (big-endian).
	#   Q> An unsigned quad (64-bit) value (big-endian).
	#   q< A signed quad (64-bit) value (little-endian).
	#   Q< An unsigned quad (64-bit) value (little-endian).
}

sub formatValue {
	my $value = shift;
	my $type = shift;
	my $class = shift;

	my $type_info = typeInfo($type, $class);
	return sprintf($type_info->{'formatter'}, $value);
}

sub formatOffset {
	my $offset = shift;
	$offset = formatValue($offset, 'Off');
	return colored($offset, 'offset');
}

sub walkELF {
	my $elf_fh = shift;

	my $elf_data = {};
	say(0, colored("Parsing file header", 'main_action'));
	walkELFHeaderMagicNumber($elf_fh, $elf_data);
	walkELFHeaderIdent($elf_fh, $elf_data);
	walkELFHeaderFields($elf_fh, $elf_data);
	walkELFSections($elf_fh, $elf_data);
}

sub analyseValue {
	my $table_name = shift;
	my $value = shift;

	return undef if (!exists($elf->{$table_name}));
	my $table= $elf->{$table_name};

	my $return = {};

	# Can we get a single, systematic meaning?
	if (exists($table->{'single_meaning'})) {
		$return->{'single_meaning'} = $table->{'single_meaning'};
	}

	# Are we dealing with a set of flags, by chance?
	if (exists($table->{is_flag}) && $table->{is_flag}) {
		$return->{'is_flag'} = 1;
		$return->{'name'} = {};
		$return->{'meaning'} = {};
		for my $mask (keys(%{$table->{'name'}})) {
			if (($value & $mask) == $mask) {
				$return->{'name'}->{$mask}    = $table->{'name'}->{$mask};
				$return->{'meaning'}->{$mask} = $table->{'meaning'}->{$mask};
			}
		}
		return $return;
	}

	# Can we get a value-specific name and/or a meaning?
	for my $info ('name', 'meaning') {
		if (exists($table->{$info})) {
			if (exists($table->{$info}->{$value})) {
				$return->{$info} = $table->{$info}->{$value};
			}
		}
	}
	return $return if (keys(%$return));

	# It seems we got neither a name nor a meaning.
	# => Try ranges now.
	if (exists($table->{'ranges'})) {
		for my $range (keys(%{$table->{'ranges'}})) {
			my $lo = $table->{'ranges'}->{$range}->{'low_value'};
			my $hi = $table->{'ranges'}->{$range}->{'high_value'};
			if ($value >= $lo && $value <= $hi) {
				return $table->{'ranges'}->{$range};
			}
		}
	}

	# Still there? Seriously? Well, is this fatal?
	if (exists($table->{'unexplained_value'})) {
		$return->{'unexplained_value'} = $table->{'unexplained_value'};
		return $return;
	}
	return undef;
}

sub analyseAndExplainValue {
	my $value = shift;
	my $table_name = shift;
	my $type = shift;
	my $class = shift;

	my $analysis = analyseValue($table_name, $value);
	return undef if (!defined($analysis));

	my $str = sprintf(
		'%s is %s',
		colored($table_name, 'value_name'),
		colored(formatValue($value, $type, $class), 'value')
	);

	if (exists($analysis->{'single_meaning'})) {
		$str .= sprintf(' -- %s.', $analysis->{'single_meaning'});
	}
	elsif (exists($analysis->{'is_flag'})) {
		if (keys(%{$analysis->{'name'}})) {
			$str .= ", i.e. the following flags:";
			for my $mask (keys(%{$analysis->{'name'}})) {
				$str .= sprintf(
					"\n  - %s (%s): %s",
					colored($analysis->{'name'}->{$mask}, 'flag_name'),
					colored(formatValue($mask, $type, $class), 'flag_value'),
					$analysis->{'meaning'}->{$mask}
				);
			}
		}
		else {
			$str .= " (no flags)";
		}
	}
	elsif (exists($analysis->{'name'}) && exists($analysis->{'meaning'})) {
		$str .= sprintf(
			', i.e. %s: %s.',
			colored($analysis->{'name'}, 'name'),
			$analysis->{'meaning'}
		);
	}
	elsif (exists($analysis->{'low_value'})) {
		$str .= sprintf(
			', between %s (%s) and %s (%s): %s',
			$analysis->{'low_name'},
			formatValue($analysis->{'low_value'}, $type, $class),
			$analysis->{'high_name'},
			formatValue($analysis->{'high_value'}, $type, $class),
			$analysis->{'meaning'}
		);
	}
	elsif (exists($analysis->{'unexplained_value'})) {
		if ($analysis->{'unexplained_value'} eq 'fatal') {
			$str .= ", which is illegal, aborting.";
			exitWithMessage(100, $str);
		}
		elsif ($analysis->{'unexplained_value'} eq 'warning') {
			$str .= ", which is probably abnormal, ignoring.";
		}
		else {
			$str .= ", " . $analysis->{'unexplained_value'} . ".";
		}
	}
	return $str;
}

sub walkELFHeaderMagicNumber {
	my $elf_fh = shift;
	my $elf_data = shift;
	my $data;

	# 0x7f, E, L, F
	read($elf_fh, $data, 1);
	if ($data eq "\x7f") {
		print "    EI_MAG0 is 0x7f (127) as expected\n";
	}
	else {
		exitWithMessage(100, "EI_MAG0 is not 0x7f as expected, aborting.");
	}

	read($elf_fh, $data, 1);
	if ($data eq 'E') {
		print "    EI_MAG1 is 'E' as expected\n";
	}
	else {
		exitWithMessage(100, "EI_MAG1 is not 'E' as expected, aborting.");
	}

	read($elf_fh, $data, 1);
	if ($data eq 'L') {
		print "    EI_MAG2 is 'L' as expected\n";
	}
	else {
		exitWithMessage(100, "EI_MAG2 is not 'L' as expected, aborting.");
	}

	read($elf_fh, $data, 1);
	if ($data eq 'F') {
		print "    EI_MAG3 is 'F' as expected\n";
	}
	else {
		exitWithMessage(100, "EI_MAG3 is not 'F' as expected, aborting.");
	}
}

sub walkELFHeaderIdent {
	my $elf_fh = shift;
	my $elf_data = shift;
	my $data;

	read($elf_fh, $data, 1);
	if ($data eq "\x1") {
		print "    EI_CLASS is 1, i.e. ELFCLASS32: 32-bit objects\n";
		setDefaultClass(ELFCLASS32);
	}
	elsif ($data eq "\x2") {
		print "    EI_CLASS is 2, i.e. ELFCLASS64: 64-bit objects\n";
		setDefaultClass(ELFCLASS64);
	}
	else {
		exitWithMessage(100, "EI_CLASS is neither 1 nor 2 as expected, aborting.");
	}

	read($elf_fh, $data, 1);
	if ($data eq "\x1") {
		print "    EI_DATA is 1, i.e. ELFDATA2LSB: object file data structures are little-endian\n";
		setDefaultEndianess(LITTLE_ENDIAN);
	}
	elsif ($data eq "\x2") {
		print "    EI_DATA is 1, i.e. ELFDATA2MSB: object file data structures are big-endian\n";
		setDefaultEndianess(BIG_ENDIAN);
	}
	else {
		exitWithMessage(100, "EI_DATA is neither 1 nor 2 as expected, aborting.");
	}

	read($elf_fh, $data, 1);
	if ($data eq "\x1") {
		print "    EI_VERSION is 1, i.e. EV_CURRENT.\n";
	}
	else {
		printf("    EI_VERSION is 0x%X, i.e. not EV_CURRENT, ignoring.\n", ord($data));
	}

	read($elf_fh, $data, 1);
	if ($data eq "\x0") {
		print "    EI_OSABI is 0, i.e. ELFOSABI_SYSV: System V ABI\n";
	}
	elsif ($data eq "\x1") {
		print "    EI_OSABI is 1, i.e. ELFOSABI_HPUX: HP-UX operating system\n";
	}
	elsif ($data eq "\xff") {
		print "    EI_OSABI is 255, i.e. ELFOSABI_STANDALONE: standalone (embedded) application\n";
	}
	else {
		printf("    EI_OSABI is 0x%02X, which is unexpected, ignoring.\n", ord($data));
	}

	read($elf_fh, $data, 1);
	printf("    EI_ABIVERSION is 0x%02X.\n", ord($data));

	print "    Seeking to offset EI_NIDENT (16).\n";
	seek($elf_fh, 16, Fcntl::SEEK_SET);
}

sub walkELFHeaderFields {
	my $elf_fh = shift;
	my $elf_data = shift;
	my $data;

	my $ind = 1;
	for my $entry (@{$elf_structures->{'file_header'}->{'ordered_entries'}}) {
		my $type = $elf_structures->{'file_header'}->{$entry};
		my $value = $elf_data->{$entry} = readELFValue($elf_fh, $type);
		say($ind, analyseAndExplainValue($elf_data->{$entry}, $entry, $type));

		if ($entry eq 'e_entry') {
			say($ind + 1, 'Here, zero means there is no entry point.') if (!$value);
		}
		elsif ($entry eq 'e_phnum') {
			my $e_phentsize = $elf_data->{'e_phentsize'};
			say($ind + 1, sprintf('conclusion: the program header table is %d x %d = %d bytes', $e_phentsize, $value, $e_phentsize * $value));
		}
		elsif ($entry eq 'e_shnum') {
			my $e_shentsize = $elf_data->{'e_shentsize'};
			say($ind + 1, sprintf('conclusion: sections are indexed from 0 (this index is reserved though) to %d.', $value - 1));
			say($ind + 1, sprintf('conclusion: the section header table is %d x %d = %d bytes', $e_shentsize, $value, $e_shentsize * $value));
		}
	}
}

sub announceELFSection {
	my ($ind, $prefix, $index, $suffix) = @_;
	say(
		$ind,
		colored($prefix . ' section #', 'underline') .
		colored($index, 'index underline') .
		colored($suffix, 'underline')
	);
}

sub walkELFSections {
	my $elf_fh = shift;
	my $elf_data = shift;

	say(0, colored('Parsing sections', 'main_action'));
	$elf_data->{'sections'} = {};
	my $ind = 1;

	announceELFSection($ind, 'Parsing', $elf_data->{'e_shstrndx'}, ' first as it holds section names:');
	walkELFSection($elf_fh, $elf_data, $elf_data->{'e_shstrndx'});

	announceELFSection($ind, 'Not parsing', 0, ' as it is reserved.');
	say($ind + 1, "It must contain only zeroes.");

	for (my $i = 1; $i < $elf_data->{'e_shnum'}; ++ $i) {
		next if ($i == $elf_data->{'e_shstrndx'});
		announceELFSection($ind, 'Parsing', $i, ':');
		walkELFSection($elf_fh, $elf_data, $i);
	}
}

sub walkELFSection {
	my $elf_fh = shift;
	my $elf_data = shift;
	my $section_index = shift;

	my $ind = 2;
	my $offset = sectionOffset($elf_data, $section_index);
	say(
		$ind,
		sprintf(
			"Seeking to offset shoff + (%s x shentsize) = %s.",
			colored($section_index, 'index'),
			formatOffset($offset)
		)
	);
	seek($elf_fh, $offset, Fcntl::SEEK_SET);

	my $type, my $value, my $details;
	my $section = {};
	# For each entry of a section header...
	for my $entry (@{$elf_structures->{'section_header'}->{'ordered_entries'}}) {
		# get its type, ...
		$type = $elf_structures->{'section_header'}->{$entry};
		# read its value, ...
		$value = $section->{$entry} = readELFValue($elf_fh, $type);
		# and provide a first basic explanation.
		say($ind, analyseAndExplainValue($section->{$entry}, $entry, $type));

		# For some entries, complete with extra explanations or details.
		my $details = '';
		if ($entry eq 'sh_addr') {
			$details = "Here, zero means the section is not allocated to the memory image of the program." if (!$value);
		}
		elsif ($entry eq 'sh_size') {
			if ($section->{'sh_type'} == 8) { # 8 is SHT_NOBITS
				$details = sprintf(
					"Here, since this is a %s section, this is the amount of space\noccupied in memory, not in the file.",
					colored('SHT_NOBITS', 'name')
				);
			}
		}
		elsif ($entry eq 'sh_link') {
			if ($value) {
				# sh_link is non-zero -- what is the use of this link, considering the current section type?
				my $sh_type = $section->{'sh_type'};
				if (exists($elf->{'sh_link'}->{'_use'}->{$sh_type})) {
					$details = sprintf(
						"Here, since this is a %s section, section #%s should be \n%s",
						colored($elf->{'sh_type'}->{'name'}->{$sh_type}, 'name'),
						colored($section->{'sh_link'}, 'index'),
						$elf->{'sh_link'}->{'_use'}->{$sh_type}
					);
				}
			}
		}
		elsif ($entry eq 'sh_info') {
			if ($value) {
				# sh_info is non-zero -- what is the use of this info, considering the current section type?
				my $sh_type = $section->{'sh_type'};
				if (exists($elf->{'sh_info'}->{'_use'}->{$sh_type})) {
					$details = sprintf(
						"Here, since this is a %s section, this should represent \n%s.",
						colored($elf->{'sh_type'}->{'name'}->{$sh_type}, 'name'),
						$elf->{'sh_info'}->{'_use'}->{$sh_type}
					);
				}
			}
		}
		elsif ($entry eq 'sh_addralign') {
			$details = 'This value must be a power of two.';
			if (!isPowerOfTwo($section->{'sh_addralign'})) {
				$details = colored($details, 'error');
			}
		}
		say($ind + 1, $details) if (length($details));
	}

	# Push the resulting section into $elf_data so sectionName() can leverage it.
	$elf_data->{'sections'}->{$section_index} = $section;

	my $sh_offname = sectionNameOffset($elf_data, $section_index);
	if (!defined($sh_offname)) {
		say($ind, colored('Error: unable to compute section name offset.', 'error'));
	}
	else {
		my $sh_strname = sectionName($elf_fh, $elf_data, $section_index);
		if (!length($sh_strname)) {
			say($ind, colored('Error: unable to retrieve section name.', 'error'));
		}
		else {
			$section->{'sh_strname'} = $sh_strname;
			$sh_strname = colored($sh_strname, 'name');
			say($ind, 'Fetched name at offset ' . formatOffset($sh_offname) . ': ' . $sh_strname);
		}
	}
}

sub sectionOffset {
	my $elf_data = shift;
	my $section_index = shift;

	return undef if ($section_index < 0);
	return undef if ($section_index >= $elf_data->{'e_shnum'});
	return $elf_data->{'e_shoff'} + ($section_index * $elf_data->{'e_shentsize'});
}

sub sectionNameOffset {
	my $elf_data = shift;
	my $section_index = shift;

	# We need the index of the section holding section names.
	return undef if (!exists($elf_data->{'e_shstrndx'}));
	my $shstrndx = $elf_data->{'e_shstrndx'};

	# We need details about that section.
	return undef if (!exists($elf_data->{'sections'}));
	return undef if (!exists($elf_data->{'sections'}->{$shstrndx}));

	# Especially, we need its offset in the ELF file.
	return undef if (!exists($elf_data->{'sections'}->{$shstrndx}->{'sh_offset'}));
	my $shstroffset = $elf_data->{'sections'}->{$shstrndx}->{'sh_offset'};

	# We add it the sh_name offset of the given section.
	return undef if (!exists($elf_data->{'sections'}->{$section_index}));
	return undef if (!exists($elf_data->{'sections'}->{$section_index}->{'sh_name'}));
	return $shstroffset + $elf_data->{'sections'}->{$section_index}->{'sh_name'};
}

sub sectionName {
	my $elf_fh = shift;
	my $elf_data = shift;
	my $section_index = shift;

	# Compute the offset to the section name.
	my $name_offset = sectionNameOffset($elf_data, $section_index);
	return undef if (!defined($name_offset));

	# Seek to that offset.
	seek($elf_fh, $name_offset, Fcntl::SEEK_SET);

	# Read data into a string until we stumble upon EOF or 0x00.
	my $name;
	my $read_bytes;
	while (1) {
		$read_bytes = read($elf_fh, my $char, 1);
		last if ($read_bytes != 1 || $char eq "\x0");
		$name .= $char;
	}
	return $name;
}

sub isPowerOfTwo {
	my $value = shift;
	return $value && !($value & ($value - 1));
}

exit(0);
